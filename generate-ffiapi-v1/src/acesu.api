
module acesu.core = 1 {
    error assertion_failure = 1;

    command nop = 1 { cookie: u64 }
    event nop = 1 { cookie: u64 }

    interface runtime {
        ctor create();

        ctor clone(r: ref runtime);

        dtor destroy;

        verbatim cppapi declaration #{
            runtime(runtime&& other);
            runtime(const runtime& other);

            runtime& operator=(runtime&& other);
            runtime& operator=(const runtime& other);

            void swap(runtime& other);
        }#

        verbatim cppapi definition #{
            inline runtime::runtime(runtime&& other)
                : runtime()
            {
                this->swap(other);
            }

            inline runtime::runtime(const runtime& other)
            {
                ::acesu::core::ffi::acesu_core_runtime_clone(&other.interface_data, &this->interface_data);
            }

            inline runtime& runtime::operator=(runtime&& other)
            {
                this->swap(other);
                return *this;
            }

            inline runtime& runtime::operator=(const runtime& other)
            {
                runtime cloned{other};
                this->swap(cloned);
                return *this;
            }

            inline void runtime::swap(runtime& other)
            {
                auto stored = other.interface_data;
                other.interface_data = this->interface_data;
                this->interface_data = stored;
            }
        }#
    }

    interface buffer {
        /// Borrow a block of memory from the caller.
        ctor borrow(r: ref runtime, p: pointer, s: size);

        /// Allocate a buffer of size `s`.
        ctor allocate(r: ref runtime, s: size);

        dtor destroy;

        /// Appends the contents of the specified buffer at the end of this buffer.
        method append_contents_of(b: ref buffer);

        /// Copies at most `s` bytes of the buffer contents into the memory at `d`.
        method copy_contents_to(d: pointer, s: size) -> size;
    }

    interface event_source {
        ctor create(r: ref runtime);

        dtor destroy;

        method wait(count: size);
    }

    interface command_queue {
        /// Create a `command_queue` that is attached to `eq`. Any events generated by the commands issued on this
        /// queue will be delivered via `eq`.
        ctor create(eq: ref event_source, c: size);

        dtor destroy;

        /// Push a command `c` with argument data in `a` and user data `u`.
        method push(c: code command, a: buffer, u: user_data);

        /// Submit all recorded commands.
        method submit();

        method as_runtime_ref() -> runtime;

        verbatim cppapi declaration #{
            template <typename T>
            auto push(T& t, user_data u) -> void;
        }#

        verbatim cppapi definition #{
            template <typename T>
            auto command_queue::push(T& t, user_data u) -> void
            {
                push(get_command_code(t), buffer::borrow(as_runtime_ref(), &t, sizeof(T)), u);
            }
        }#
    }
}
